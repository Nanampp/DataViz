[["index.html", "Proyecto DataViz Chapter 1 Sobre este libro 1.1 Objetivos 1.2 Paquetes Necesarios", " Proyecto DataViz Jorge Arteaga y Adriana Palacio 2021-12-10 Chapter 1 Sobre este libro Este libro contiene el detalle del proyecto enfocado a sistemas de información geográfica. Se estará trabajando con un archivo tomado de Kaggle en https://www.kaggle.com/dgomonov/data-exploration-on-nyc-airbnb que contiene información resumida y métricas para Airbnb en la ciudad de Nueva York en 2019. 1.1 Objetivos Este documento pretente encontrar como están distribuidos los precios de los airbnb en Nueva York. Haciendo un análisis por anfitrión, por tipo de alojamiento y por grupo de vecindario. Para lograr esto, realizaremos: Un análisis preliminar de los datos. Un análisis de datos faltantes y atípicos que puedan entorpecer las conclusiones. Un análisis por distribución geográfica. Con estos resultados se construirá una aplicación en Shiny. 1.2 Paquetes Necesarios Para poder trabajar con estos datos se hace necesario cargar una serie de librerías. Para el cargue del archivo csv, utilizaremos el paquete readr. Para el manejo de dataframe, utilizaremos el paquete dplyr. Para revisión de datos faltantes, utilizaremos los paquetes mice y VIM. Para conexión a la base de datos PostgreSQL, utilizaremos el paquete RPostgresL. Para poder hacer uso de la API y realizar la conexión a la base de datos con éxito, utilizaremos el paquete DBI. Para poder identificar datos atípicos, utilizaremos los paquetes outliers y EnvStats. 7 Para graficar, utilizararemos el paquete ggplot2. Para generar gráficos dinámicos, utilizaremos el paquete plotly. Para visualización en mapas, utilizaremos el paquete ggmap. Para la construcción de la aplicación, utilizaremos los paquetes shiny y shinythemes. library(readr) library(dplyr) library(mice) library(VIM) library(RPostgres) library(DBI) library(outliers) library(EnvStats) library(ggplot2) library(plotly) library(ggmap) library(shiny) library(shinythemes) "],["cargue-y-limpieza-de-datos.html", "Chapter 2 Cargue y Limpieza de Datos 2.1 Carga de datos 2.2 Revisión de datos faltantes 2.3 Creación en base de datos", " Chapter 2 Cargue y Limpieza de Datos En este capítulo abordaremos el cargue de los datos de Airbnb de la ciudad de Nueva York en el año 2019. 2.1 Carga de datos El archivo CSV con el listado de Airbnb de la ciudad de Nueva York para el año 2019 descargado de Kaggle se cargará en una base de datos en Heroku Postgress. Pero para lograr esto, primero debemos cargar como dataframe el archivo a través de la función read.csv(), agregando la instrucción na = c(\"\", \"NA\") para tomar los valores vacíos como datos faltantes na. airbnb &lt;- read.csv(file = &quot;Datasets/AB_NYC_2019.csv&quot;, na = c(&quot;&quot;, &quot;NA&quot;)) head(airbnb) ## id name host_id host_name ## 1 2539 Clean &amp; quiet apt home by the park 2787 John ## 2 2595 Skylit Midtown Castle 2845 Jennifer ## 3 3647 THE VILLAGE OF HARLEM....NEW YORK ! 4632 Elisabeth ## 4 3831 Cozy Entire Floor of Brownstone 4869 LisaRoxanne ## 5 5022 Entire Apt: Spacious Studio/Loft by central park 7192 Laura ## 6 5099 Large Cozy 1 BR Apartment In Midtown East 7322 Chris ## neighbourhood_group neighbourhood latitude longitude room_type price ## 1 Brooklyn Kensington 40.64749 -73.97237 Private room 149 ## 2 Manhattan Midtown 40.75362 -73.98377 Entire home/apt 225 ## 3 Manhattan Harlem 40.80902 -73.94190 Private room 150 ## 4 Brooklyn Clinton Hill 40.68514 -73.95976 Entire home/apt 89 ## 5 Manhattan East Harlem 40.79851 -73.94399 Entire home/apt 80 ## 6 Manhattan Murray Hill 40.74767 -73.97500 Entire home/apt 200 ## minimum_nights number_of_reviews last_review reviews_per_month ## 1 1 9 2018-10-19 0.21 ## 2 1 45 2019-05-21 0.38 ## 3 3 0 &lt;NA&gt; NA ## 4 1 270 2019-07-05 4.64 ## 5 10 9 2018-11-19 0.10 ## 6 3 74 2019-06-22 0.59 ## calculated_host_listings_count availability_365 ## 1 6 365 ## 2 2 355 ## 3 1 365 ## 4 1 194 ## 5 1 0 ## 6 1 129 Este archivo contiene 48.895 registros y 16 variables para análisis. En la siguiente sección revisaremos si existen datos faltantes en el dataset. 2.2 Revisión de datos faltantes Para determinar la existencia de datos faltantes en el dataframe Airbnb, primero determinaremos por columna cual es su proporción de valores na. pMiss &lt;- function(x){sum(is.na(x))/length(x)*100} apply(airbnb,2,pMiss) ## id name ## 0.00000000 0.03272318 ## host_id host_name ## 0.00000000 0.04294918 ## neighbourhood_group neighbourhood ## 0.00000000 0.00000000 ## latitude longitude ## 0.00000000 0.00000000 ## room_type price ## 0.00000000 0.00000000 ## minimum_nights number_of_reviews ## 0.00000000 0.00000000 ## last_review reviews_per_month ## 20.55833930 20.55833930 ## calculated_host_listings_count availability_365 ## 0.00000000 0.00000000 Tenemos valores faltantes en las colunmnas name, host_name, last_review y reviews_per_month, sin embargo, solo estas dos últimas están por encima del umbral seguro (5%), lo que podría indicarnos a priori que son variables que deben eliminarse porque no aportarán al análisis. Sin embargo, esta es una decisión que debe tomarse con un mayor análisis de estos registros. Haremos uso de la función md.pattern del paquete mice, que nos brinda visualmente el patrón de los datos faltantes, para un mejor entendimiento de estos. md.pattern(airbnb, plot = TRUE, rotate.names=TRUE) ## id host_id neighbourhood_group neighbourhood latitude longitude room_type ## 38821 1 1 1 1 1 1 1 ## 10037 1 1 1 1 1 1 1 ## 16 1 1 1 1 1 1 1 ## 5 1 1 1 1 1 1 1 ## 6 1 1 1 1 1 1 1 ## 10 1 1 1 1 1 1 1 ## 0 0 0 0 0 0 0 ## price minimum_nights number_of_reviews calculated_host_listings_count ## 38821 1 1 1 1 ## 10037 1 1 1 1 ## 16 1 1 1 1 ## 5 1 1 1 1 ## 6 1 1 1 1 ## 10 1 1 1 1 ## 0 0 0 0 ## availability_365 name host_name last_review reviews_per_month ## 38821 1 1 1 1 1 0 ## 10037 1 1 1 0 0 2 ## 16 1 1 0 1 1 1 ## 5 1 1 0 0 0 3 ## 6 1 0 1 1 1 1 ## 10 1 0 1 0 0 3 ## 0 16 21 10052 10052 20141 El patrón nos indica que 38.821 registros no tienen datos faltantes, que los datos faltantes se encuentran en las colunmnas name, host_name, last_review y reviews_per_month (como habíamos encontrado anteriormente), con 16, 21, 10.052 y 10.052 registros, respectivamente. Adicionalmente, el mayor número de registros con datos faltantes (10.037) se encuentran en el patrón que solo contiene na en las columnas last_review y reviews_per_month y solo hay tres filas que contienen más de un valor perdido y de esas solo dos contienen más de dos valores perdidos. Haciendo uso del paquete VIM, podemos ver la proporción de datos faltantes gráficamente. Por cuestión de espacio y mejor visualización del gráfico, trabajaremos solo con la columnas identificadas anteriormente que tienen datos faltantes. airbnb_columns=airbnb[,c(&quot;name&quot;,&quot;host_name&quot;,&quot;last_review&quot;,&quot;reviews_per_month&quot;)] aggr(airbnb_columns, numbers=TRUE, sortVars=TRUE, labels=names(data), cex.axis=.5, gap=3) ## ## Variables sorted by number of missings: ## Variable Count ## last_review 0.2055833930 ## reviews_per_month 0.2055833930 ## host_name 0.0004294918 ## name 0.0003272318 El gráfico de barras anterior, nos muestra que las columnas last_review y reviews_per_month representan la mayor proporción de datos faltantes y la proporción para la columnas name y host_name no es significativa. Este nuevo patrón nos complemente el anterior obtenido con el paquete micepuesto que nos indica adicionalmente que el 79,4% de los datos no tienen datos perdidos y nos muestra la proporción de filas que tienen un determinado patrón de datos perdidos, por ejemplo, el 20,52% tienen el patrón de datos perdidos sólo en las columnas en las columnas last_review y reviews_per_month. El número de datos perdidos en el dataframe es bastante significativo (20.6%), sin embargo, al analizar lo que significan las columnas que los tienen, vemos por un lado que para el análisis posterior las columnas name y host_name no son necesarias y pueden eliminarse. borrar = c(&quot;name&quot;, &quot;host_name&quot;) airbnb = airbnb[, !(names(airbnb) %in% borrar)] head(airbnb) ## id host_id neighbourhood_group neighbourhood latitude longitude ## 1 2539 2787 Brooklyn Kensington 40.64749 -73.97237 ## 2 2595 2845 Manhattan Midtown 40.75362 -73.98377 ## 3 3647 4632 Manhattan Harlem 40.80902 -73.94190 ## 4 3831 4869 Brooklyn Clinton Hill 40.68514 -73.95976 ## 5 5022 7192 Manhattan East Harlem 40.79851 -73.94399 ## 6 5099 7322 Manhattan Murray Hill 40.74767 -73.97500 ## room_type price minimum_nights number_of_reviews last_review ## 1 Private room 149 1 9 2018-10-19 ## 2 Entire home/apt 225 1 45 2019-05-21 ## 3 Private room 150 3 0 &lt;NA&gt; ## 4 Entire home/apt 89 1 270 2019-07-05 ## 5 Entire home/apt 80 10 9 2018-11-19 ## 6 Entire home/apt 200 3 74 2019-06-22 ## reviews_per_month calculated_host_listings_count availability_365 ## 1 0.21 6 365 ## 2 0.38 2 355 ## 3 NA 1 365 ## 4 4.64 1 194 ## 5 0.10 1 0 ## 6 0.59 1 129 Por otro lado, al analizar los registros faltantes en las columnas last_review y reviews_per_month, encontramos que todos corresponden a aquellos donde no existen una evaluación por lo tanto, el manejo de estos datos es simple y se procede de la siguiente manera, se asigna un 0 en la columna reviews_per_month y se elimina la columna last_review por no tener valor significativo para nuestro análisis posterior. borrar = c(&quot;last_review&quot;) airbnb = airbnb[, !(names(airbnb) %in% borrar)] airbnb &lt;- mutate_at(airbnb, c(&quot;reviews_per_month&quot;), ~replace(., is.na(.), 0)) head(airbnb) ## id host_id neighbourhood_group neighbourhood latitude longitude ## 1 2539 2787 Brooklyn Kensington 40.64749 -73.97237 ## 2 2595 2845 Manhattan Midtown 40.75362 -73.98377 ## 3 3647 4632 Manhattan Harlem 40.80902 -73.94190 ## 4 3831 4869 Brooklyn Clinton Hill 40.68514 -73.95976 ## 5 5022 7192 Manhattan East Harlem 40.79851 -73.94399 ## 6 5099 7322 Manhattan Murray Hill 40.74767 -73.97500 ## room_type price minimum_nights number_of_reviews reviews_per_month ## 1 Private room 149 1 9 0.21 ## 2 Entire home/apt 225 1 45 0.38 ## 3 Private room 150 3 0 0.00 ## 4 Entire home/apt 89 1 270 4.64 ## 5 Entire home/apt 80 10 9 0.10 ## 6 Entire home/apt 200 3 74 0.59 ## calculated_host_listings_count availability_365 ## 1 6 365 ## 2 2 355 ## 3 1 365 ## 4 1 194 ## 5 1 0 ## 6 1 129 En este punto nuestros datos ya no tienen valores faltantes y trabajaremos en adelante con un dataframe de 48.895 y 13 variables. apply(airbnb,2,pMiss) ## id host_id ## 0 0 ## neighbourhood_group neighbourhood ## 0 0 ## latitude longitude ## 0 0 ## room_type price ## 0 0 ## minimum_nights number_of_reviews ## 0 0 ## reviews_per_month calculated_host_listings_count ## 0 0 ## availability_365 ## 0 2.3 Creación en base de datos El dataframe sin datos faltantes generado en la sección anterior debe cargarse en una base de datos en Heroku Postgress. Para esto primero debemos conectarnos a ella, usando la función dbConnect() con los datos apropiados. con &lt;- dbConnect(RPostgres::Postgres(), dbname = &quot;d41lsl8qgestjf&quot;, host = &quot;ec2-3-229-43-149.compute-1.amazonaws.com&quot;, port = 5432, user = &quot;uqtxfaqjjcxggw&quot;, password = &quot;916d311356954de6a99118d13578bb9d1b47bdc86cb8360a60b9606293bd882d&quot;) Una vez tengamos establecida la conexión, insertamos los datos en la tabla airbnb, usando la función dbWriteTable() dbWriteTable(con, &#39;airbnb&#39;, airbnb, row.names=FALSE, overwrite=TRUE) Verifiquemos que podamos leer los datos, através de la función dbGetQuery() df = dbGetQuery(con, &quot;SELECT * FROM airbnb&quot;) summary(df) ## id host_id neighbourhood_group neighbourhood ## Min. : 2539 Min. : 2438 Length:48895 Length:48895 ## 1st Qu.: 9471945 1st Qu.: 7822033 Class :character Class :character ## Median :19677284 Median : 30793816 Mode :character Mode :character ## Mean :19017143 Mean : 67620011 ## 3rd Qu.:29152178 3rd Qu.:107434423 ## Max. :36487245 Max. :274321313 ## latitude longitude room_type price ## Min. :40.50 Min. :-74.24 Length:48895 Min. : 0.0 ## 1st Qu.:40.69 1st Qu.:-73.98 Class :character 1st Qu.: 69.0 ## Median :40.72 Median :-73.96 Mode :character Median : 106.0 ## Mean :40.73 Mean :-73.95 Mean : 152.7 ## 3rd Qu.:40.76 3rd Qu.:-73.94 3rd Qu.: 175.0 ## Max. :40.91 Max. :-73.71 Max. :10000.0 ## minimum_nights number_of_reviews reviews_per_month ## Min. : 1.00 Min. : 0.00 Min. : 0.000 ## 1st Qu.: 1.00 1st Qu.: 1.00 1st Qu.: 0.040 ## Median : 3.00 Median : 5.00 Median : 0.370 ## Mean : 7.03 Mean : 23.27 Mean : 1.091 ## 3rd Qu.: 5.00 3rd Qu.: 24.00 3rd Qu.: 1.580 ## Max. :1250.00 Max. :629.00 Max. :58.500 ## calculated_host_listings_count availability_365 ## Min. : 1.000 Min. : 0.0 ## 1st Qu.: 1.000 1st Qu.: 0.0 ## Median : 1.000 Median : 45.0 ## Mean : 7.144 Mean :112.8 ## 3rd Qu.: 2.000 3rd Qu.:227.0 ## Max. :327.000 Max. :365.0 "],["análisis-exploratorio-de-los-datos.html", "Chapter 3 Análisis Exploratorio de los datos Resumen de los datos Datos Atípicos Análisis del anfitrion Análisis de los precios", " Chapter 3 Análisis Exploratorio de los datos En este capítulo abordaremos el análisis exploratorio de los datos EDA para el listado de Airbnb de la ciudad de Nueva York en el año 2019. Resumen de los datos Empezamos el análisis exploratorio de nuestros datos con las estadísticas de resumen, haciendo uso de la función summary para los datos contenidos en la tabla airbnb de nuestra base de datos en Heroku con &lt;- dbConnect(RPostgres::Postgres(), dbname = &quot;d41lsl8qgestjf&quot;, host = &quot;ec2-3-229-43-149.compute-1.amazonaws.com&quot;, port = 5432, user = &quot;uqtxfaqjjcxggw&quot;, password = &quot;916d311356954de6a99118d13578bb9d1b47bdc86cb8360a60b9606293bd882d&quot;) df = dbGetQuery(con, &quot;SELECT * FROM airbnb&quot;) summary(df) ## id host_id neighbourhood_group neighbourhood ## Min. : 2539 Min. : 2438 Length:48895 Length:48895 ## 1st Qu.: 9471945 1st Qu.: 7822033 Class :character Class :character ## Median :19677284 Median : 30793816 Mode :character Mode :character ## Mean :19017143 Mean : 67620011 ## 3rd Qu.:29152178 3rd Qu.:107434423 ## Max. :36487245 Max. :274321313 ## latitude longitude room_type price ## Min. :40.50 Min. :-74.24 Length:48895 Min. : 0.0 ## 1st Qu.:40.69 1st Qu.:-73.98 Class :character 1st Qu.: 69.0 ## Median :40.72 Median :-73.96 Mode :character Median : 106.0 ## Mean :40.73 Mean :-73.95 Mean : 152.7 ## 3rd Qu.:40.76 3rd Qu.:-73.94 3rd Qu.: 175.0 ## Max. :40.91 Max. :-73.71 Max. :10000.0 ## minimum_nights number_of_reviews reviews_per_month ## Min. : 1.00 Min. : 0.00 Min. : 0.000 ## 1st Qu.: 1.00 1st Qu.: 1.00 1st Qu.: 0.040 ## Median : 3.00 Median : 5.00 Median : 0.370 ## Mean : 7.03 Mean : 23.27 Mean : 1.091 ## 3rd Qu.: 5.00 3rd Qu.: 24.00 3rd Qu.: 1.580 ## Max. :1250.00 Max. :629.00 Max. :58.500 ## calculated_host_listings_count availability_365 ## Min. : 1.000 Min. : 0.0 ## 1st Qu.: 1.000 1st Qu.: 0.0 ## Median : 1.000 Median : 45.0 ## Mean : 7.144 Mean :112.8 ## 3rd Qu.: 2.000 3rd Qu.:227.0 ## Max. :327.000 Max. :365.0 De las columnas de nuestro dataframe, podemos decir por ejemplo que el precio de una noche de los airbnb oscila entre 0 y 10.000 dólares con un promedio de 152.7 dólares, más adelante revisaremos si un precio diario de 10.000 dólares es o no un dato atípico. Adicionalmente, los alojamientos se pueden reservar desde una (1) noche, sin embargo hay algunos cuyas noches mínimas son de 1.250, alrededor de 3.5 años, esto también es un candidato a dato atípico que será revisado en la siguente sección. Por otro lado, existen anfitriones que tienen hasta 327 alojamientos en la región. A pesar, que las columnas id, host_id, latitude y longitude son numéricas, no son relevantes las métricas de mínimo, máximo, media y cuartiles. Evaluando los valores que pueden tomar las variables categóricas usando la función unique, encontramos que los tipos de alojamiento disponibles son: Habitaciones privadas (Private room), Apartamentos Completos (Entire home/apt) o Habitaciones compartidas (Shared room) y tenemos grupos de vencindarios como Brooklyn, Manhattan, Qeens, Staten Island y Bronx y en total 221 vecindarios disponibles para alojamiento. unique(df$room_type) ## [1] &quot;Private room&quot; &quot;Entire home/apt&quot; &quot;Shared room&quot; unique(df$neighbourhood_group) ## [1] &quot;Brooklyn&quot; &quot;Manhattan&quot; &quot;Queens&quot; &quot;Staten Island&quot; ## [5] &quot;Bronx&quot; length(unique(df$neighbourhood)) ## [1] 221 Datos Atípicos Tenemos sospechas que existen datos atípicos en las columnas price y minimum_nights. Al analizar los histogramas y boxplots encontramos que estos abarcan la mayor parte del rango de las variables. par(mfrow = c(1, 2)) g1 = ggplot(df) + aes(x = price) + geom_histogram(fill = &quot;blue&quot;) + theme_minimal() g2 = ggplot(df) + aes(x = minimum_nights) + geom_histogram(fill = &quot;red&quot;) + theme_minimal() g3 = ggplot(df) + aes(x = &quot;&quot;, y = price) + geom_boxplot(fill = &quot;blue&quot;) + theme_minimal() g4 = ggplot(df) + aes(x = &quot;&quot;, y = minimum_nights) + geom_boxplot(fill = &quot;red&quot;) + theme_minimal() fig = subplot(g1, g3,g2,g4, nrows = 2, shareX = FALSE) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. annotations = list( list( x = 0.2, y = 1.0, text = &quot;Price&quot;, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;center&quot;, yanchor = &quot;bottom&quot;, showarrow = FALSE ), list( x = 0.8, y = 1, text = &quot;&quot;, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;center&quot;, yanchor = &quot;bottom&quot;, showarrow = FALSE ), list( x = 0.2, y = 0.43, text = &quot;Minimum_nights&quot;, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;center&quot;, yanchor = &quot;bottom&quot;, showarrow = FALSE ), list( x = 0.8, y = 0.45, text = &quot;&quot;, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;center&quot;, yanchor = &quot;bottom&quot;, showarrow = FALSE )) fig &lt;- fig %&gt;%layout(annotations = annotations) #options(warn = -1) fig Según la función boxplot.stats()$out que se basa en el criterio IQR, los valores atípicos para el precio son aquellos mayores que 335 mientras que para el mínimo de noches el umbral está en 12. min(boxplot.stats(df$price)$out) ## [1] 335 min(boxplot.stats(df$minimum_nights)$out) ## [1] 12 Si revisamos por el criterio de los percentiles, teniendo en cuenta que las observaciones por fuera del intervalo formado por los percentiles 2.5 y 97.5 se consideran posibles valores atípicos, encontramos que para el precio son potenciales datos atípicos aquellos por debajo de 30 y por encima de 799 y en el caso de las noches mínimas, aquellas obervaciones por debajo de 1 y por encima de 30. c(quantile(df$price, 0.025), quantile(df$price, 0.975)) ## 2.5% 97.5% ## 35 500 c(quantile(df$minimum_nights, 0.025), quantile(df$minimum_nights, 0.975)) ## 2.5% 97.5% ## 1 30 Otro método, es el filtro de Hampel que determina un dato atípico estableciendo un intervalo formado por la mediana, teniendo entonces para este caso que si el precio está por encima de 244 y las noches minimas superan las 9. c(median(df$price) - 3 * mad(df$price, constant = 1), median(df$price) + 3 * mad(df$price, constant = 1)) ## [1] -32 244 c(median(df$minimum_nights) - 3 * mad(df$minimum_nights, constant = 1), median(df$minimum_nights) + 3 * mad(df$minimum_nights, constant = 1)) ## [1] -3 9 Ahora bien, revisemos la prueba de Grubbs haciendo uso de la función grubbs.test que detecta si el valor más alto o más bajo del conjunto de datos es un valor atípico. grubbs.test(df$price) ## ## Grubbs test for one outlier ## ## data: df$price ## G = 41.00399, U = 0.96561, p-value &lt; 2.2e-16 ## alternative hypothesis: highest value 10000 is an outlier grubbs.test(df$price, opposite = TRUE) ## ## Grubbs test for one outlier ## ## data: df$price ## G = 0.63593, U = 0.99999, p-value = 1 ## alternative hypothesis: lowest value 0 is an outlier grubbs.test(df$minimum_nights) ## ## Grubbs test for one outlier ## ## data: df$minimum_nights ## G = 60.60150, U = 0.92489, p-value &lt; 2.2e-16 ## alternative hypothesis: highest value 1250 is an outlier grubbs.test(df$minimum_nights, opposite = TRUE) ## ## Grubbs test for one outlier ## ## data: df$minimum_nights ## G = 0.29399, U = 1.00000, p-value = 1 ## alternative hypothesis: lowest value 1 is an outlier Teniendo un umbral \\(\\alpha = 0.05\\), tenemos que para el caso del precio, el p-valor es menor cuando se evalua la hipótesis nula \\(H_0: \\text{El valor más alto no es un valor atípico}\\) pero es mayor que este umbral escogido cuando se evalua la hopótesis nula \\(H_0: \\text{El valor más bajo no es un valor atípico}\\), por lo tanto la primera hipótesis se rechaza y la segunda se acepta por lo que se concluye que el valor más alto es valor atípico y el valor más bajo no lo es. Obtenemos el mismo resultado en el caso de las noches mínimas. En este caso no realizamos la prueba de Dixon, que al igual que la Grubbs detecta si el valor más alto o más bajo es atípico porque esta prueba funciona mejor en conjunts de datos que tienen menos de 25 elementos y este no es nuestro caso. Sin embargo, realizaremos una última prueba, la de Rosner que a diferencia de las otras nos ayuda a detectar varios valores atípicos a la vez, eso usando la función rosnerTest. Esta prueba debe recibir además del dataset, el número de presuntos valores atípicos. Para determinar dicho número, usaremos los resultados de las pruebas anteriores (no basadas en el valor p), dónde habíamos encontrados en un caso que los valores por encima de 500 para el precio y por encima de 30 para las noches mínimas, representaban valores atípicos. El número de registros por encima de estos valores será usado como el k de la función rosnerTest. nrow(df[df$price&gt;500, ]) ## [1] 1044 test &lt;- rosnerTest(df$price, k = 1044) ## Warning in rosnerTest(df$price, k = 1044): The true Type I error may be larger than assumed. ## Although the help file for &#39;rosnerTest&#39; has a table with information ## on the estimated Type I error level, ## simulations were not run for k &gt; 10 or k &gt; floor(n/2). test$all.stats[920:930, ] ## i Mean.i SD.i Value Obs.Num R.i+1 lambda.i+1 Outlier ## 920 919 132.5990 90.40292 575 16080 4.893659 4.882919 TRUE ## 921 920 132.5898 90.38129 575 18748 4.894932 4.882915 TRUE ## 922 921 132.5805 90.35966 575 35866 4.896205 4.882911 TRUE ## 923 922 132.5713 90.33802 575 36558 4.897480 4.882907 TRUE ## 924 923 132.5621 90.31637 575 39405 4.898756 4.882903 TRUE ## 925 924 132.5529 90.29472 575 41174 4.900033 4.882899 TRUE ## 926 925 132.5437 90.27306 575 46799 4.901311 4.882895 TRUE ## 927 926 132.5344 90.25139 573 26778 4.880430 4.882890 FALSE ## 928 927 132.5252 90.22992 561 48233 4.748699 4.882886 FALSE ## 929 928 132.5163 90.20965 560 3522 4.738780 4.882882 FALSE ## 930 929 132.5074 90.18947 560 18130 4.739939 4.882878 FALSE nrow(df[df$minimum_nights&gt;30, ]) ## [1] 747 test &lt;- rosnerTest(df$minimum_nights, k = 747) ## Warning in rosnerTest(df$minimum_nights, k = 747): The true Type I error may be larger than assumed. ## Although the help file for &#39;rosnerTest&#39; has a table with information ## on the estimated Type I error level, ## simulations were not run for k &gt; 10 or k &gt; floor(n/2). test$all.stats[460:470, ] ## i Mean.i SD.i Value Obs.Num R.i+1 lambda.i+1 Outlier ## 460 459 5.749195 8.478871 50 21326 5.218950 4.884804 TRUE ## 461 460 5.748281 8.476575 50 21545 5.220472 4.884800 TRUE ## 462 461 5.747368 8.474277 50 26030 5.221995 4.884796 TRUE ## 463 462 5.746454 8.471978 50 31054 5.223520 4.884792 TRUE ## 464 463 5.745540 8.469679 50 32545 5.225046 4.884788 TRUE ## 465 464 5.744626 8.467379 50 32909 5.226573 4.884784 TRUE ## 466 465 5.743713 8.465078 50 42890 5.228102 4.884780 TRUE ## 467 466 5.742799 8.462776 50 43673 5.229632 4.884776 TRUE ## 468 467 5.741885 8.460473 47 12930 4.876573 4.884772 FALSE ## 469 468 5.741033 8.458483 47 20986 4.877821 4.884768 FALSE ## 470 469 5.740181 8.456492 45 7 4.642566 4.884764 FALSE El test de Rosner nos indica que son valores atípicos, precios a partir de 575 dólares y noches mínimas a partir de 50. Usando este criterio, eliminamos el 2.8% de nuestros datos, resultando un dataframe con 1370 registros menos. nrow(df) ## [1] 48895 nrow(df[df$price&gt;=575 | df$minimum_nights&gt;=50 , ]) ## [1] 1370 nrow(df[df$price&gt;=575 | df$minimum_nights&gt;=50 , ])/nrow(df)*100.00 ## [1] 2.801922 Una vez eliminados estos datos atípicos, reemplazamos los registros de la tabla airbnb creada nuevamente con estos sin datos atípicos, usando la función dbWriteTable() df_out = df[df$price&lt;575 &amp; df$minimum_nights&lt;50, ] dbWriteTable(con, &#39;airbnb&#39;, df_out, row.names=FALSE, overwrite=TRUE) Volvemos a extraer las estadísticas de resumen: summary(df_out) ## id host_id neighbourhood_group neighbourhood ## Min. : 2539 Min. : 2438 Length:47525 Length:47525 ## 1st Qu.: 9477988 1st Qu.: 7837510 Class :character Class :character ## Median :19670481 Median : 30791331 Mode :character Mode :character ## Mean :19009503 Mean : 67424381 ## 3rd Qu.:29095078 3rd Qu.:107434423 ## Max. :36487245 Max. :274321313 ## latitude longitude room_type price ## Min. :40.50 Min. :-74.24 Length:47525 Min. : 0.0 ## 1st Qu.:40.69 1st Qu.:-73.98 Class :character 1st Qu.: 68.0 ## Median :40.72 Median :-73.96 Mode :character Median :102.0 ## Mean :40.73 Mean :-73.95 Mean :132.5 ## 3rd Qu.:40.76 3rd Qu.:-73.94 3rd Qu.:175.0 ## Max. :40.91 Max. :-73.71 Max. :573.0 ## minimum_nights number_of_reviews reviews_per_month ## Min. : 1.00 Min. : 0.00 Min. : 0.000 ## 1st Qu.: 1.00 1st Qu.: 1.00 1st Qu.: 0.050 ## Median : 2.00 Median : 5.00 Median : 0.390 ## Mean : 5.73 Mean : 23.66 Mean : 1.108 ## 3rd Qu.: 5.00 3rd Qu.: 24.00 3rd Qu.: 1.630 ## Max. :47.00 Max. :629.00 Max. :58.500 ## calculated_host_listings_count availability_365 ## Min. : 1.000 Min. : 0.0 ## 1st Qu.: 1.000 1st Qu.: 0.0 ## Median : 1.000 Median : 42.0 ## Mean : 7.101 Mean :110.8 ## 3rd Qu.: 2.000 3rd Qu.:220.0 ## Max. :327.000 Max. :365.0 Con estos cambios en nuestro dataframe, podemos ver que los precios ahora oscilan entre 0 y 573 dólares y las noches mínimas no superan las 47 (mes y medio), lo cual tiene mayor sentido para nuestro análisis. Análisis del anfitrion A través de la función de agrupación group_by, podemos obtener los anfitriones con más alojamientos disponibles. Hemos encontrando que el anfitrión con mayor número de alojamientos tiene 317 lo que no es consistente con la columna calculated_host_listings_count (327) y esto se debe a que hemos eliminado datos del dataframe original una vez identificados los valores atípicos, es por esto, que esta columna, se eliminará. df_out %&gt;% group_by(host_id) %&gt;% summarise(n = n()) %&gt;% arrange(desc(n)) %&gt;% head(5) -&gt; top_hostid ## `summarise()` ungrouping output (override with `.groups` argument) g = ggplot(data= top_hostid, aes(x = reorder(factor(host_id), n), y=n)) + geom_bar(stat=&quot;identity&quot;, fill = &quot;blue&quot;) + xlab(&quot;Host_Id&quot;) + ylab(&quot;Cant. alojamientos&quot;) + ggtitle(&quot;Top 5 de los anfitriones con más alojamientos&quot;) ggplotly(g) borrar = c(&quot;calculated_host_listings_count&quot;) df_out = df_out[, !(names(df_out) %in% borrar)] Ahora, revisemos la distribución de alojamientos por grupos de vecindarios. df_host = filter(df_out, host_id %in% top_hostid$host_id) df_host%&gt;% group_by(host_id, neighbourhood_group) %&gt;% summarise(n = n()) %&gt;% ggplot(aes(x=factor(host_id), y=n, fill=factor(neighbourhood_group))) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;)+ xlab(&quot;Host_id&quot;) + ylab(&quot;Cant. Alojamientos&quot;) + ggtitle(&quot;Top 5 de anfitriones con más alojamientos distribuidos por grupo vecindario&quot;)+ theme(legend.title = element_blank()) -&gt; g ## `summarise()` regrouping output by &#39;host_id&#39; (override with `.groups` argument) ggplotly(g) A pesar, que los grupos de vecindarios disponibles corresponden a Brooklyn, Manhattan, Qeens, Staten Island y Bronx, vemos que los anfitriones con más alojamientos no tienen disponibilidad en Staten Island y Bronx, la mayoría de estos alojamientos se encuentran en Manhattan y solo dos de estos cinco tienen alojamientos en Brooklyn y el anfitrion 137358866 es el único con alojamiento en Queens Si revisamos la distribución de los precios de estos cinco anfitriones, atraves, de un boxplot, tenemos que el anfitrion 107434423 tiene el mayor precio promedio y el anfitrion 137358866 tiene todos sus alojamnientos en precios similares y más bajos en comparación con los otros. p &lt;- plot_ly(df_host, y = ~price, alpha = 0.1, boxpoints = &quot;suspectedoutliers&quot;) p1 &lt;- p %&gt;% add_boxplot(x = &quot;Overall&quot;) p2 &lt;- p %&gt;% add_boxplot(x = ~factor(host_id)) subplot( p1, p2, shareY = TRUE, widths = c(0.2, 0.8), margin = 0 ) %&gt;% hide_legend() El host 107434423 tiene precios por encima de la media del top 5 de anfitriones mientras que el host 137358866, los tiene por debajo. El host 12243051 tiene los precios más simétricos sin valores atípicos, mientras que el host 219517861 tiene alojamientos variedad de valores encontrando bastantes alojamientos con valores superiores considerados valores atípicos. Análisis de los precios Si ahora revisamos los precios, vemos que el mayor precio promedio por noche está en la zona de Manhattan para los tres tipos de alojamiento, adicionalmente y como era de esperarse, es más costoso un alojamiento completo, seguido de una habitación privada y por útimo una habitación compartida, aunque no hay una gran diferencia entre los valores promedios de las habitaciones. Este patrón se mantiene igual, independiente del grupo de vecindario al que pertenezca. df_out %&gt;% group_by(neighbourhood_group, room_type)%&gt;% summarise(m = mean(price)) -&gt; group_type ## `summarise()` regrouping output by &#39;neighbourhood_group&#39; (override with `.groups` argument) group_type%&gt;% ggplot(aes(x=room_type, y=m, fill=room_type)) + geom_bar(stat=&quot;identity&quot;)+ facet_wrap(~neighbourhood_group)+ xlab(&quot;Grupo Vecindario&quot;) + ylab(&quot;Precio Medio&quot;) + ggtitle(&quot;Precio promedio por grupo de vecindario y tipo de alojamiento&quot;)+ theme(axis.text.y = element_text(angle = 90))+ theme(axis.text.x=element_blank(), legend.title = element_blank())-&gt; g ggplotly(g) ggplot(data=df_out, mapping = aes(x=neighbourhood_group, y=price)) + geom_boxplot(aes(color = neighbourhood_group))+ theme(legend.title = element_blank()) -&gt; g ggplotly(g) El grupo de vecindario con el precio promedio más alto es Manhattan y en este grupo se manejan el mayor rango de precios. Los precios para Queen y Staten Island tienen distribuciones similares. Si agrupamos por tipo de alojamiento, vemos que los valores por habitación compartida en Staten Island presentan un sesgo positivo. En cuanto a las habitaciones privadas tenemos una alta concentración de valores atípicos. En los alojamientos completos por grupo el precio promedio es menor a 200 y en el caso de Bronx y Staten Island es sesgo es positivo y Manhattan es el que tiene mayor variación de precios en sus alojamientos. ggplot(data=df_out, mapping = aes(x=neighbourhood_group, y=price)) + geom_boxplot(width=0.8, aes(color = neighbourhood_group))+ facet_wrap(~room_type)+ theme(legend.title = element_blank(), axis.text.y=element_blank())+ coord_flip()-&gt; g ggplotly(g) "],["visualización-en-mapas.html", "Chapter 4 Visualización en mapas", " Chapter 4 Visualización en mapas Para los datos de interés, contamos con la ubicación (latitud, longitud) de los alojamientos en Nueva York. Revisaremos la distribución de estos en un mapa, através de la función gg_map, ubicándonos precisamente en Nueva York, encontrando que la menor cantidad de alojamientos se encuentra en Staten Island y la mayor en Queens. con &lt;- dbConnect(RPostgres::Postgres(), dbname = &quot;d41lsl8qgestjf&quot;, host = &quot;ec2-3-229-43-149.compute-1.amazonaws.com&quot;, port = 5432, user = &quot;uqtxfaqjjcxggw&quot;, password = &quot;916d311356954de6a99118d13578bb9d1b47bdc86cb8360a60b9606293bd882d&quot;) df_out = dbGetQuery(con, &quot;SELECT * FROM airbnb&quot;) mykey = &quot;AIzaSyCRgNUY6U40KR4MHy0RHKsUxsSRLkE_0i0&quot; register_google(key = mykey) myLocation &lt;- &quot;Nueva York&quot; myMap &lt;- get_map(location = myLocation, zoom = 10) ## Source : https://maps.googleapis.com/maps/api/staticmap?center=Nueva%20York&amp;zoom=10&amp;size=640x640&amp;scale=2&amp;maptype=terrain&amp;language=en-EN&amp;key=xxx ## Source : https://maps.googleapis.com/maps/api/geocode/json?address=Nueva+York&amp;key=xxx ggmap(myMap) + geom_point(data=df_out, aes(x = longitude, y = latitude, colour= neighbourhood_group))+ theme(legend.title = element_blank())-&gt; g ggplotly(g) En Bronx, hay pocos precios altos en los alojamientos y los que existen se encuentran a los alrededores de la localidad. Si nos enfocamos en Manhattan, vemos que hay una clara división en los precios, los menores se encuentran al norte y los mayores al sur. Y en general hay pocos alojamientos con precios altos en comparación con los de precios bajos. ggmap(myMap) + geom_point(data=df_out, aes(x = longitude, y = latitude, colour= price))+ scale_color_gradientn(colours = rainbow(5))+ facet_wrap(~neighbourhood_group, nrow = 2) -&gt; g ggplotly(g) "],["aplicación-con-shiny.html", "Chapter 5 Aplicación con Shiny 5.1 Host 5.2 Grupo Vecindario 5.3 Participación 5.4 Mapas", " Chapter 5 Aplicación con Shiny Con el análisis anterior, hemos contruido una aplicación web que se encuentra desplegada en el servidor de ShinyApps.io en la ruta https://zxzunm-adriana-palacio.shinyapps.io/Airbnb/. La aplicación consta de 4 pestañas Host, Grupo Vecindario, Participación, Mapas. 5.1 Host Esta pestaña contiene información de los 5 anfitriones con más alojamientos distribuidos por grupo de vecindario. Inicialmente nos muestra un gráfico con la cantidad de alojamientos que tienen los anfitriones seleccionados. Pero, al hacer click sobre una de las barras, nos genera un nuevo gráfico con la distribución de los alojamientos por grupo de vecindario para el host seleccionado. 5.2 Grupo Vecindario Esta pestaña nos permite seleccionar el tipo de alojamiento (uno o más) y el grupo de alojamiento (solo uno) y nos muestra dos gráficos. El primero, con la información de los precios promedios por grupo de vecindario y tipo de alojamiento, este gráfico sólo se ve afectado por el filtro de tipo de alojamiento. Por otro lado, el segundo gráfico nos muestra los precios promedios en los vencindarios del grupo escogido y los tipos de alojamientos seleccionados 5.3 Participación Esta pestaña muestra el porcentaje de alojamientos por cada grupo de vecindario y en su hover nos da información sobre el grupo en el que estamos parados, el precio promeido de los alojamientos en este grupo y el porcentaje del mismo. Si seleccionamos una sección de la torta, nos lleva a un gráfico del grupo de vecindario escogido y ahora la distribución de los alojamientos se muestra por tipo de alojamiento. En esta vista, contamos con un botón back para devovlernos a la primera gráfica. 5.4 Mapas Esta última pestaña nos muestra en el primer gráfico la distribución de los alojamientos en New York por grupo de vecindario y en el segundo cómo son los precios en cada grupo. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
